/*************************************************************************
 *
 *  Copyright (c) 2020 Rajit Manohar
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 *
 **************************************************************************
 */
import "globals.act";

namespace syn {

/*
 * Build an OR-gate tree (NOR/NAND/optional INV)
 */
export template<pint N>
defproc ortree (bool? in[N]; bool out)
{
  bool tout;

  { N > 0 : "What?" };

  pint i, end, j;
  pbool isinv;
  isinv = false;
  i = 0;
  end = N-1;

  /* dynamic array that holds all the nodes in the completion tree */
  bool tmp[N];
  (k:N:tmp[k] = in[k];)

  /* Invariant: i <= end */
    
  *[ i != end ->
     /* 
      * Invariant: tmp[i..end] has the current signals that need to be
      * combined together, and "isinv" specifies if they are the inverted
      * sense or not
      */
     j = 0;
     *[ i < end ->
	/*-- there are still signals that need to be combined --*/
	j = j + 1;
	bool tmp[end+j..end+j];
	[ i+2 >= end ->
	  /*-- last piece: use either a 2 or 3 input C-element --*/
	  [isinv -> 
	     prs { (&k:i..end:tmp[k]) => tmp[end+j]- }
	  [] else ->
	     prs { (|k:i..end:tmp[k]) => tmp[end+j]- }
          ]	      
	  i = end;
        [] else ->
	  /*-- more to come; so use a two input C-element --*/
	  [isinv -> 
	     prs { (&k:i..i+1:tmp[k]) => tmp[end+j]- }
	  [] else ->
	     prs { (|k:i..i+1:tmp[k]) => tmp[end+j]- }
          ]	      
	  i = i + 2;
	]
      ]
      /*-- we just added an inverting layer --*/
      isinv = ~isinv;

      /*-- update range that has to be combined --*/
      i = end+1;
      end = end+j;
      j = 0;
  ]
  /*-- invert the signal if needed --*/
  [isinv -> prs { tmp[end] => out- } 
  [] else -> tmp[end] = out;
  ]
}
  
/*
 * Build a completion tree using a combination of 2-input and 3-input
 * C-elements 
 */
export template<pint N; pbool invert>
defproc ctree (bool? in[N]; bool out)
{
  bool tout;

  { N > 0 : "What?" };

  pint i, end, j;
  pbool isinv;
  isinv = invert;
  i = 0;
  end = N-1;

  /* dynamic array that holds all the nodes in the completion tree */
  bool tmp[N];
  (k:N:tmp[k] = in[k];)

  /* Invariant: i <= end */
    
  *[ i != end ->
     /* 
      * Invariant: tmp[i..end] has the current signals that need to be
      * combined together, and "isinv" specifies if they are the inverted
      * sense or not
      */
     j = 0;
     *[ i < end ->
	/*-- there are still signals that need to be combined --*/
	j = j + 1;
	bool tmp[end+j..end+j];
	[ i+2 >= end ->
	  /*-- last piece: use either a 2 or 3 input C-element --*/
	  prs { (&k:i..end:tmp[k]) #> tmp[end+j]- }
	  i = end;
        [] else ->
	  /*-- more to come; so use a two input C-element --*/
          prs { (&k:i..i+1:tmp[k]) #> tmp[end+j]- }
	  i = i + 2;
	]
      ]
      /*-- we just added an inverting layer --*/
      isinv = ~isinv;

      /*-- update range that has to be combined --*/
      i = end+1;
      end = end+j;
      j = 0;
  ]
  /*-- invert the signal if needed --*/
  [isinv -> prs { tmp[end] => out- } 
  [] else -> tmp[end] = out;
  ]
}

export template<pint N>
defproc sigbuf (bool in, out)
{
 { N > 0 : "sigbuf: parameter error" };

 bool _out;

 [ N < 8 -> in = out;
 [] else ->
      sigbuf<N/8> sb(in);
      prs {
      	 sb.out => _out-
	 _out   => out-
      }
      sizing {
      	 _out {-N/4}; out {-N}
      }
 ]
}

}
