/*************************************************************************
 *
 *  Copyright (c) 2020 Rajit Manohar
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 *
 **************************************************************************
 */
import "globals.act";

namespace syn {

/*
 * Datapath elements
 *
 *   Need to define:
 *      - variables
 *      - send
 *      - receive
 *      - expression evaluation
 *
 */

export template<pint W; pbool I>
defproc var_init(sdtvar<W> v) 
{
  prs {
    (i:W:
       v.r[i].f<8> -> v.r[i].t-
       v.r[i].t<8> -> v.r[i].f-
      [weak=1] ~v.r[i].t<4,4> -> v.r[i].f+
      [weak=1] ~v.r[i].f<4,4> -> v.r[i].t+

      Reset -> v.r[i].d[int(~I)]-
     )
  }
}


export template<pint W>
defproc transfer(a1of1? c; sdtexprchan?<W> e; sdtchan!<W> ch)
{
  c.r = e.r;
  e.d = ch.d;
  c.a = ch.a;
}

export template<pint W>
defproc recv(a1of1 c; sdtchan<W> ch; sdtvar<W> var)
{
  bool cr;
  sigbuf<2*W> s(c.r,cr);

  bool wack[W];
    
  prs {
    (i:W:
       [keeper=0] cr & ch.d.r[i].t -> var.r[i].f-
       [keeper=0] cr & ch.d.r[i].f -> var.r[i].t-

      cr & ((var.r[i].t & ch.d.r[i].t) | (var.r[i].f & ch.d.r[i].f)) -> wack[i]-
      ~cr  & ~ch.d.r[i].t & ~ch.d.r[i].f -> wack[i]+
     )
  }

  ctree<W> ct(wack);
  
  prs {
    Reset | ct.out => c.a-
  }
}


export template<pint W,N>
defproc muxinport(sdtchan?<W> c; sdtchan<W> m[N])
{
  { N > 0 : "Parameter out of range" };

  [ N = 1 -> m[0] = c;
  [] else ->
       { false : "FIXME" };
  ]
}

export template<pint W,N>
defproc muxoutport(sdtchan!<W> c; sdtchan<W> m[N])
{
  { N > 0 : "Parameter out of range" };

  [ N = 1 -> m[0] = c;
  [] else ->
       { false : "FIXME" };
  ]
}


export namespace expr {

export template<pint W1,W2>
defproc and(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

export template<pint W1,W2>
defproc or(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

export template<pint W1,W2>
defproc xor(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

  
export template<pint W1,W2>
defproc add(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out);

export template<pint W1,W2>
defproc sub(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out);

export template<pint W1,W2>
defproc mult(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+W2> out);

export template<pint W1,W2>
defproc div(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);
  
export template<pint W1,W2>
defproc mod(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W2> out);
  
export template<pint W1,W2>
defproc lsl(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+(1<<W2)> out);

export template<pint W1,W2>
defproc lsr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);
  
export template<pint W1,W2>
defproc asr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);

export template<pint W1,W2>
defproc lt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc gt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);
  
export template<pint W1,W2>
defproc le(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc ge(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);
  
export template<pint W1,W2>
defproc lt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc eq(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc ne(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W>
defproc uminus(sdtexprchan<W> a; sdtexprchan<W> out);
  
export template<pint W>
defproc not(sdtexprchan<W> a; sdtexprchan<W> out);
  
export template<pint W1,W2>
defproc ite(sdtexprchan<1> a; sdtexprchan<W1> opt1; sdtexprchan<W2> opt2; sdtexprchan<max(W1,W2)> out);

export template<pint W1, W2>
defproc widthconv(sdtexprchan<W1> a; sdtexprchan<W2> out);

export template<pint W,V>
defproc const(sdtexprchan<W> out);

/*-- we need to fix this for variables ---*/
export template<pint W>
defproc writeport(sdtvar<W> var; sdtchan<W> in)
{
  

}

export template<pint W>
defproc readport(sdtvar<W> var; sdtexprchan<W> out)
{


}


}

}
