/*************************************************************************
 *
 *  Copyright (c) 2020 Rajit Manohar
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 *
 **************************************************************************
 */
import "globals.act";

namespace syn {

/*
 * Datapath elements
 *
 *   Need to define:
 *      - variables
 *      - send
 *      - receive
 *      - expression evaluation
 *
 */

export template<pint W; pbool I>
defproc var_init(sdtvar<W> v) 
{
  prs {
    (i:W:
       v.r[i].f<8> -> v.r[i].t-
       v.r[i].t<8> -> v.r[i].f-
      [weak=1] ~v.r[i].t<4,4> -> v.r[i].f+
      [weak=1] ~v.r[i].f<4,4> -> v.r[i].t+

      Reset -> v.r[i].d[int(~I)]-
     )
  }
}


export template<pint W>
defproc transfer(a1of1? c; sdtexprchan?<W> e; sdtchan!<W> ch)
{
  c.r = e.r;
  e.d = ch.d;
  c.a = ch.a;
}

export template<pint W>
defproc recv(a1of1 c; sdtchan<W> ch; sdtvar<W> var)
{
  bool cr;
  sigbuf<2*W> s(c.r,cr);

  bool wack[W];
    
  prs {
    (i:W:
       [keeper=0] cr & ch.d.r[i].t -> var.r[i].f-
       [keeper=0] cr & ch.d.r[i].f -> var.r[i].t-

      cr & ((var.r[i].t & ch.d.r[i].t) | (var.r[i].f & ch.d.r[i].f)) -> wack[i]-
      ~cr  & ~ch.d.r[i].t & ~ch.d.r[i].f -> wack[i]+
     )
  }

  ctree<W,false> ct(wack);
  
  prs {
    Reset | ct.out => c.a-
  }
  c.a = ch.a;
}


export template<pint W,N>
defproc muxinport(sdtchan?<W> c; sdtchan<W> m[N])
{
  { N > 0 : "Parameter out of range" };

  [ N = 1 -> m[0] = c;
  [] else ->
       { false : "FIXME" };
  ]
}

export template<pint W,N>
defproc muxoutport(sdtchan!<W> c; sdtchan<W> m[N])
{
  { N > 0 : "Parameter out of range" };

  [ N = 1 -> m[0] = c;
  [] else ->
       { false : "FIXME" };
  ]
}


export namespace expr {

export template<pint W1,W2>
defproc and(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out)
{
  pint wmin = min(W1,W2);
  pint wmax = max(W1,W2);

  bool _t[wmax], _f[wmax];

  prs {
    (i:wmin: a.d.r[i].t & b.d.r[i].t -> _t[i]-
     a.d.r[i].f & (b.d.r[i].t | b.d.r[i].f) | a.d.r[i].t & b.d.r[i].f -> _f[i]-
     ~a.d.r[i].t & ~b.d.r[i].t -> _t[i]+
     ~a.d.r[i].t & ~b.d.r[i].t & ~a.d.r[i].f & ~b.d.r[i].f -> _f[i]+

     _t[i] => out.d.r[i].t-
     _f[i] => out.d.r[i].f-
     )
  }
  
  [ W1 > W2 ->
    prs {
        (i:wmin..wmax-1:  a.d.r[i].t | a.d.r[i].f -> _f[i]-
                         ~a.d.r[i].t & ~a.d.r[i].f -> _f[i]+
                          _f[i] => out.d.r[i].f-
        )
    }
 [] else ->
    prs {
      (i:wmin..wmax-1:  b.d.r[i].t | b.d.r[i].f -> _f[i]-
                     ~b.d.r[i].t & ~b.d.r[i].f -> _f[i]+
                      _f[i] => out.d.r[i].f-
      )
    }
  ]
  (i:wmin..wmax-1: GND = out.d.r[i].t;)

  out.r = a.r;
  out.r = b.r;  
}

export template<pint W1,W2>
defproc or(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out)
{
  pint wmin = min(W1,W2);
  pint wmax = max(W1,W2);

  bool _t[wmax], _f[wmax];

  prs {
    (i:wmin: a.d.r[i].f & b.d.r[i].f  -> _f[i]-
     a.d.r[i].t & (b.d.r[i].t | b.d.r[i].f) | a.d.r[i].f & b.d.r[i].t -> _t[i]-
     ~a.d.r[i].f & ~b.d.r[i].f -> _f[i]+
     ~a.d.r[i].t & ~b.d.r[i].t & ~a.d.r[i].f & ~b.d.r[i].f -> _t[i]+

     _t[i] => out.d.r[i].t-
     _f[i] => out.d.r[i].f-
    )
  }
  
  [ W1 > W2 ->
    (i:wmin..wmax-1: a.d.r[i].d = out.d.r[i].d;)
 [] else ->
    (i:wmin..wmax-1: b.d.r[i].d = out.d.r[i].d;)
  ]
  out.r = a.r;
  out.r = b.r;  
}

export template<pint W1,W2>
defproc xor(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out)
{
  pint wmin = min(W1,W2);
  pint wmax = max(W1,W2);

  bool _t[wmax], _f[wmax];

  prs {
    (i:wmin: a.d.r[i].f & b.d.r[i].t | a.d.r[i].t & b.d.r[i].f -> _t[i]-
     a.d.r[i].t & b.d.r[i].t | a.d.r[i].f & b.d.r[i].f -> _f[i]-
     ~a.d.r[i].t & ~b.d.r[i].t & ~a.d.r[i].f & ~b.d.r[i].f -> _t[i]+
     ~a.d.r[i].t & ~b.d.r[i].t & ~a.d.r[i].f & ~b.d.r[i].f -> _f[i]+

     _t[i] => out.d.r[i].t-
     _f[i] => out.d.r[i].f-
    )
  }
  
  [ W1 > W2 ->
    (i:wmin..wmax-1: a.d.r[i].d = out.d.r[i].d;)
 [] else ->
    (i:wmin..wmax-1: b.d.r[i].d = out.d.r[i].d;)
  ]
  out.r = a.r;
  out.r = b.r;
}
  
export template<pint W>
defproc not(sdtexprchan<W> a; sdtexprchan<W> out)
{
  a.r = out.r;
  (i:W: a.d.r[i].t = out.d.r[i].f;
        a.d.r[i].f = out.d.r[i].t;
   )
}

defproc fadd(dualrail a, b, cin; dualrail s, cout)
{
  bool _st, _sf, _ct, _cf;
  prs {
    a.t & b.t | (a.t | b.t) & cin.t -> _ct-
    ~a.t & ~a.f & ~b.t & ~b.f -> _ct+

    a.f & b.f | (a.f | b.f) & cin.f -> _cf-
    ~a.t & ~a.f & ~b.t & ~b.f -> _cf+

      cin.t & (a.t & b.t | a.f & b.f) |
      cin.f & (a.t & b.f | a.f & b.t) -> _st-
      ~cin.t & ~cin.f -> _st+

      cin.t & (a.f & b.t | a.t & b.f) |
      cin.f & (a.f & b.f | a.t & b.t) -> _sf-
      ~cin.t & ~cin.f -> _sf+

    _ct => cout.t-
    _cf => cout.f-
    _st => s.t-
    _sf => s.f-
 }
}

defproc hadd(dualrail a, b; dualrail s, cout)
{
  bool _st, _sf, _ct, _cf;
  prs {
    a.t & b.t -> _ct-
    ~a.t & ~a.f -> _ct+

    a.f & (b.t | b.f) | b.f & a.t -> _cf-
    ~a.t & ~a.f -> _cf+

    a.t & b.f | a.f & b.t -> _st-
    ~b.t & ~b.f -> _st+

    a.f & b.f | a.t & b.t -> _sf-
   ~b.t & ~b.f -> _sf+

    _ct => cout.t-
    _cf => cout.f-
    _st => s.t-
    _sf => s.f-
 }
}

defproc hadd1(dualrail a, b; dualrail s, cout)
{
  bool _st, _sf, _ct, _cf;
  prs {
    a.t & (b.t|b.f) | a.f & b.t -> _ct-
    ~a.t & ~a.f -> _ct+

    a.f & b.f -> _cf-
    ~a.t & ~a.f -> _cf+

    a.t & b.f | a.f & b.t -> _sf-
    ~b.t & ~b.f -> _sf+

    a.f & b.f | a.t & b.t -> _st-
   ~b.t & ~b.f -> _st+

    _ct => cout.t-
    _cf => cout.f-
    _st => s.t-
    _sf => s.f-
 }
}

template<pint W1,W2>
defproc addfblock(dualrails<W1> a; dualrails<W2> b; dualrail cin;
		  dualrails<max(W1,W2)> s; dualrail cout)
{
  pint wmin = min(W1,W2);
  pint wmax = max(W1,W2);

  { wmin > 0 : "addfblock: minimum width is zero?" };

  fadd fa[wmin];
  [ wmax > wmin -> hadd ha[wmin..wmax-1]; ]

  /* wire up primary inputs and outputs */

  (i:wmin: fa[i](.a=a.r[i], .b=b.r[i], .s=s.r[i]);)
  [ W1 > W2 -> (i:wmin..wmax-1: ha[i](.a=a.r[i],.s=s.r[i]);
		[ i != wmin -> ha[i-1].cout=ha[i].b; ]
		)
 [] W2 > W1 -> (i:wmin..wmax-1: ha[i](.a=b.r[i],.s=s.r[i]);
		[ i != wmin -> ha[i-1].cout=ha[i].b; ]
		)
  ]

  /* carries */
  fa[0].cin = cin;
  (i:wmin-1: fa[i].cout = fa[i+1].cin;)

  [wmax > wmin -> ha[wmax-1].cout = cout;
 [] else -> fa[wmax-1].cout = cout;
  ]   
}

export template<pint W1,W2>
defproc add(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out)
{
  pint wmin = min(W1,W2);
  pint wmax = max(W1,W2);

  { wmin > 0 : "add: minimum width is zero?" };

  out.r = a.r;
  out.r = b.r;

  [ wmin = 1 ->
    // this is only a half adder
    hadd ha[wmax];
    [ W1 > W2 ->  (i:wmax: ha[i](.a=a.d.r[i],.s=out.d.r[i]);)
                  ha[0].b=b.d.r[0];
                 (i:1..wmax-1: ha[i].b=ha[i-1].cout;)
                 ha[wmax-1].cout=out.d.r[wmax];
   [] W2 > W1 ->  (i:wmax: ha[i](.a=b.d.r[i],.s=out.d.r[i]);)
                  ha[0].b=a.d.r[0];
                 (i:1..wmax-1: ha[i].b=ha[i-1].cout;)
                 ha[wmax-1].cout=out.d.r[wmax];
      [] else -> ha[0](.a = a.d.r[0], .b = b.d.r[0], .s = out.d.r[0],
		       .cout = out.d.r[1]);
    ]
  [] else ->
       /* lsb is a half adder */
       hadd ha[1];
       addfblock<W1-1,W2-1> fb;
       fb.a.r = a.d.r[1..W1-1];
       fb.b.r = b.d.r[1..W2-1];
       fb.s.r = out.d.r[1..wmax-1];
       fb.cout = out.d.r[wmax];
       ha[0](.a=a.d.r[0],.b=b.d.r[0],.s=out.d.r[0],.cout=fb.cin);
  ]
}

export template<pint W1,W2>
defproc sub(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out)
{
  pint wmin = min(W1,W2);
  pint wmax = max(W1,W2);

  { wmin > 0 : "add: minimum width is zero?" };

  out.r = a.r;
  out.r = b.r;

  dualrails<W2> bc;

  (i:W2: bc.r[i].t = b.d.r[i].f;  bc.r[i].f = b.d.r[i].t; )

  [ wmin = 1 ->
    hadd1 ha0;
    hadd ha[1..wmax-1];
    [ W1 > W2 ->  (i:1..wmax-1: ha[i](.a=a.d.r[i],.s=out.d.r[i]);)
                  ha0(.a=a.d.r[0],.s=out.d.r[0]);
                  ha0.b=bc.r[0];
                  [ wmax > 1 -> ha[1].b=ha0.cout; ]
                 (i:2..wmax-1: ha[i].b=ha[i-1].cout;)
                 [ wmax = 1 -> ha0.cout=out.d.r[wmax];
		 [] else ->  ha[wmax-1].cout=out.d.r[wmax];
		 ]

    [] W2 > W1 ->  (i:1..wmax-1: ha[i](.a=bc.r[i],.s=out.d.r[i]);)
                  ha0(.a=bc.r[0],.s=out.d.r[0]);
                  ha0.b=a.d.r[0];
                  [ wmax > 1 -> ha[1].b=ha0.cout; ]
                 (i:2..wmax-1: ha[i].b=ha[i-1].cout;)
                 [ wmax = 1 -> ha0.cout=out.d.r[wmax];
		 [] else ->  ha[wmax-1].cout=out.d.r[wmax];
		 ]
      [] else -> ha0(.a = a.d.r[0], .b = bc.r[0], .s = out.d.r[0],
		       .cout = out.d.r[1]);
    ]
  [] else ->
       /* lsb is a half adder */
       hadd1 ha1;
       addfblock<W1-1,W2-1> fb;
       fb.a.r = a.d.r[1..W1-1];
       fb.b.r = bc.r[1..W2-1];
       fb.s.r = out.d.r[1..wmax-1];
       fb.cout = out.d.r[wmax];
       ha1(.a=a.d.r[0],.b=bc.r[0],.s=out.d.r[0],.cout=fb.cin);
  ]
}

export template<pint W1,W2>
defproc mult(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+W2> out)
{
  { false : "Multiplication not yet implemented" };
}

export template<pint W1,W2>
defproc div(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out)
{
  { false : "Division operator not yet implemented" };
}
  
export template<pint W1,W2>
defproc mod(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W2> out)
{
  { false : "Modulo operator not yet implemented" };
}
  
export template<pint W1,W2>
defproc lsl(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+(1<<W2)> out);

export template<pint W1,W2>
defproc lsr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);
  
export template<pint W1,W2>
defproc asr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);

/*------------------------------------------------------------------------*/

defchan d1of3 <: chan(enum<3>) (bool gt, lt, eq) { }


/*
  one bit a cmp b
*/
defproc fcmpgen(dualrail a, b; d1of3 out)
{
  bool _cgt, _clt, _ceq;
  prs {
    a.t & b.f -> _cgt-
    a.f & b.t -> _clt-
    a.t & b.t | a.f & b.f -> _ceq-
    ~a.t & ~b.f -> _cgt+
    ~a.f & ~b.t -> _clt+
    ~a.t & ~a.f & ~b.t & ~b.f -> _ceq+

   _cgt => out.gt-
   _clt => out.lt-
   _ceq => out.eq-
  }
}

/*
  a cmp 0
*/
defproc fcmpa0(dualrail a; d1of3 out)
{
  bool _cgt, _clt, _ceq;
  a.t = out.gt;
  a.f = out.eq;
  GND = out.lt;
}

/*
  0 cmp b
*/
defproc fcmpb0(dualrail b; d1of3 out)
{
  bool _cgt, _clt, _ceq;
  b.t = out.lt;
  b.f = out.eq;
  GND = out.gt;
}


defproc fcmpmerge (d1of3 msb, lsb; d1of3 out)
{
  bool _gt, _lt, _eq;
  prs {
    (msb.gt | msb.eq) & lsb.gt | msb.gt & (lsb.eq | lsb.lt) -> _gt-
    (msb.lt | msb.eq) & lsb.lt | msb.lt & (lsb.eq | lsb.gt) -> _lt-
    msb.eq & lsb.eq -> _eq-

   ~msb.gt & ~msb.eq & ~lsb.gt & ~lsb.eq & ~lsb.lt -> _gt+
   ~msb.lt & ~msb.eq & ~lsb.gt & ~lsb.eq & ~lsb.lt -> _lt+
   ~msb.eq & ~lsb.eq -> _eq+

   _lt => out.lt-
   _gt => out.gt-
   _eq => out.eq-
  }
}

/* higher index is msb */
template<pint N>
defproc fcmptree(d1of3 in[N]; d1of3 out)
{
  { N > 0 : "fcmptree: needs to be positive!" };
  [ N = 1 -> out = in[0];
  [] else -> fcmptree<N/2> t1(in[0..N/2-1]);
             fcmptree<N-N/2> t2(in[N/2..N-1]);
             fcmpmerge m(.msb=t2.out, .lsb=t1.out, .out=out);
  ]
}


export template<pint W1, W2>
defproc cmp(dualrails<W1> a; dualrails<W2> b; d1of3 out)
{
  pint wmin = min(W1,W2);
  pint wmax = max(W1,W2);

  { wmin > 0 : "lt with no bits?" };

  d1of3 cr[wmax];
    
  fcmpgen gen[wmin];
  (i:wmin: gen[i](.a = a.r[i], .b=b.r[i], .out=cr[i]);)

  [ W1 > W2 ->
    fcmpa0 ra[W1-W2];
    (i:W1-W2: ra[i](.a=a.r[i+wmin], .out=cr[i+wmin]);)
  [] W1 < W2 ->
    fcmpb0 rb[W2-W1];
    (i:W2-W1: rb[i](.b=b.r[i+wmin], .out=cr[i+wmin]);)
  ]
  
  fcmptree<wmax> t(cr,out);
}

export template<pint W1,W2>
defproc lt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out)
{
  pint wmin = min(W1,W2);
  
  { wmin > 0 : "lt with no bits?" };

  out.r = a.r;
  out.r = b.r;

  cmp<W1,W2> c(a.d,b.d);

  bool _of;
  out.d.r[0].t = c.out.lt;
  prs {
    c.out.gt | c.out.eq => _of-
    _of => out.d.r[0].f-
  }
}

export template<pint W1,W2>
defproc gt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out)
{
  lt<W2,W1> l(b,a,out);
}
  
export template<pint W1,W2>
defproc le(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out)
{
  gt<W1,W2> g(a,b);
  g.out.r = out.r;
  g.out.d.r[0].t=out.d.r[0].f;
  g.out.d.r[0].f=out.d.r[0].t;
}

export template<pint W1,W2>
defproc ge(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out)
{
  lt<W1,W2> l(a,b);
  l.out.r = out.r;
  l.out.d.r[0].t=out.d.r[0].f;
  l.out.d.r[0].f=out.d.r[0].t;
}

template<pint N>
defproc dror(dualrails<N> d; dualrails<1> out)
{
  { N > 0 : "What?" };

  pint i, end, j;
  i = 0;
  end = N-1;

  /* dynamic array that holds all the nodes in the completion tree */
  dualrail tmp[N];
  (k:N:tmp[k] = d.r[k];)

  /* Invariant: i <= end */
    
  *[ i != end ->
     /* 
      * Invariant: tmp[i..end] has the current signals that need to be
      * combined together, and "isinv" specifies if they are the inverted
      * sense or not
      */
     j = 0;
     *[ i < end ->
	/*-- there are still signals that need to be combined --*/
	j = j + 1;
	dualrail tmp[end+j..end+j];
	bool _tt[end+j..end+j], _ff[end+j..end+j];
	prs {
	  tmp[i].t & (tmp[i+1].t | tmp[i+1].f) | tmp[i+1].t & tmp[i].f -> _tt[end+j]-
         ~tmp[i].t & ~tmp[i].f & ~tmp[i+1].t & ~tmp[i+1].f -> _tt[end+j]+
	 
	  tmp[i].f & tmp[i+1].f -> _ff[end+j]-
         ~tmp[i].f & ~tmp[i+1].f -> _ff[end+j]+

	 _tt[end+j] => tmp[end+j].t-
	 _ff[end+j] => tmp[end+j].f-
         }
	i = i + 2;
     ]
      /*-- update range that has to be combined --*/
      end = end+j;
      j = 0;
  ]
  tmp[end] = out.r[0];
}

export template<pint W1,W2>
defproc eq(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out)
{
  pint wmin = min(W1,W2);
  
  { wmin > 0 : "lt with no bits?" };

  out.r = a.r;
  out.r = b.r;

  cmp<W1,W2> c(a.d,b.d);

  bool _of;
  out.d.r[0].t = c.out.eq;
  prs {
    c.out.gt | c.out.lt => _of-
    _of => out.d.r[0].f-
  }
}

export template<pint W1,W2>
defproc ne(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out)
{
  eq<W1,W2> x(a,b);
  x.out.d.r[0].t = out.d.r[0].f;
  x.out.d.r[0].f = out.d.r[0].t;
  x.out.r = out.r;
  out.r = a.r;
  out.r = b.r;
}

export template<pint W>
defproc uminus(sdtexprchan<W> a; sdtexprchan<W> out);
  

export template<pint W1,W2>
defproc ite(sdtexprchan<1> a; sdtexprchan<W1> opt1; sdtexprchan<W2> opt2; sdtexprchan<max(W1,W2)> out);


export template<pint W1, W2>
defproc widthconv(sdtexprchan<W1> a; sdtexprchan<W2> out)
{
  [ W1 = W2 -> a = out;
  [] W1 < W2 ->
    bool _xv;
    out.r = a.r;
    a.d.r = out.d.r[0..W1-1];
    prs {
      a.d.r[W1-1].t | a.d.r[W1-1].f => _xv-
      (i:W1..W2-1:  _xv => out.d.r[i].f- )
   }
   (i:W1..W2-1: GND = out.d.r[i].t;)
    
  [] W1 > W2 ->
     out.r = a.r;
     a.d.r[0..W2-1] = out.d.r;
     // XXX: dangling signals!
 ]
}

export template<pint W,V>
defproc const(sdtexprchan<W> out)
{
  bool _req;
  sigbuf<W> s(_req);

  prs {
    out.r => _req-
    (i:W:
      ~_req => out.d.r[i].d[((V >> i) & 1)]+
      Reset -> out.d.r[i].d[1-(V >> i) & 1]-
    )
  }
}


/*-- variable access ports --*/
	 
export template<pint W>
defproc writeport(sdtvar<W> var; sdtchan<W> in)
{
  bool _wack[W];
  prs {
    (i:W: [keeper=0] in.d.r[i].t -> var.r[i].f-
          [keeper=0] in.d.r[i].f -> var.r[i].t-

       (in.d.r[i].t & var.r[i].t) | (in.d.r[i].f & var.r[i].f) -> _wack[i]-
       ~in.d.r[i].t & ~in.d.r[i].f -> _wack[i]+
     )
  }
  ctree<W,false> wa(_wack);
  prs {
    Reset | wa.out => in.a-
  }
}

export template<pint W>
defproc readport(sdtvar<W> var; sdtexprchan<W> out)
{
  bool xout, _xout;

  sigbuf<2*W> s(xout,_xout);
  
  prs {
    out.r => xout-
      
    (i:W:
     ~_xout & ~var.r[i].t -> out.d.r[i].f+
     ~_xout & ~var.r[i].f -> out.d.r[i].t+
     _xout -> out.d.r[i].f-
     _xout -> out.d.r[i].t-
     )
  }
}

}

}
