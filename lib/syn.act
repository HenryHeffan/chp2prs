/*************************************************************************
 *
 *  Copyright (c) 2020 Rajit Manohar
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 *
 **************************************************************************
 */
import "globals.act";

/* Syntax directed translation */
  
namespace syn {

/*-- variable state --*/
export template<pint W; pbool I>
defproc var_init(sdtvar<W> v);
  
/*-- basic statements --*/
export
defproc sskip(a1of1 c)
{
  c.r = c.a;
}

export template<pint W>
defproc send(a1of1 c; sdtexprchan<W> e; sdtchan<W> ch);

export template<pint W>
defproc recv(a1of1 c; sdtchan<W> ch; sdtvar<W> var);

/*
 * Build an OR-gate tree (NOR/NAND)
 */
export template<pint N>
defproc ortree (bool in[N]; bool out)
{
  bool tout;

  { N > 0 : "What?" };

  pint i, end, j;
  pbool isinv;
  isinv = false;
  i = 0;
  end = N-1;

  /* dynamic array that holds all the nodes in the completion tree */
  bool tmp[N];
  (k:N:tmp[k] = in[k];)

  /* Invariant: i <= end */
    
  *[ i != end ->
     /* 
      * Invariant: tmp[i..end] has the current signals that need to be
      * combined together, and "isinv" specifies if they are the inverted
      * sense or not
      */
     j = 0;
     *[ i < end ->
	/*-- there are still signals that need to be combined --*/
	j = j + 1;
	bool tmp[end+j..end+j];
	[ i+2 >= end ->
	  /*-- last piece: use either a 2 or 3 input C-element --*/
	  [isinv -> 
	     prs { (&k:i..end:tmp[k]) => tmp[end+j]- }
	  [] else ->
	     prs { (|k:i..end:tmp[k]) => tmp[end+j]- }
          ]	      
	  i = end;
        [] else ->
	  /*-- more to come; so use a two input C-element --*/
	  [isinv -> 
	     prs { (&k:i..i+1:tmp[k]) => tmp[end+j]- }
	  [] else ->
	     prs { (|k:i..i+1:tmp[k]) => tmp[end+j]- }
          ]	      
	  i = i + 2;
	]
      ]
      /*-- we just added an inverting layer --*/
      isinv = ~isinv;

      /*-- update range that has to be combined --*/
      i = end+1;
      end = end+j;
      j = 0;
  ]
  /*-- invert the signal if needed --*/
  [isinv -> prs { tmp[end] => out- } 
  [] else -> tmp[end] = out;
  ]
}
  

  
/*-- compound statements --*/
export template<pint N>
defproc loop(a1of1 c; r1of2 g[N]; a1of1 s[N])
{
  /* loop: evaluate guards serially */
  (i:N-1: g[i].f = g[i+1].r;)
  g[N-1].f = c.a;
    
  ortree<N> t;
  (i:N: s[i](.r=g[i].t, .a=t.in[i]); )

  bool _r;

  prs {
    c.r => _r-
    _r | t.out => g[0].r-
  }
}

export template<pint N;pbool has_else>
defproc select(a1of1 c; r1of2 g[N-int(has_else)]; a1of1 s[N])
{
  (i:N-1: g[i].f = g[i+1].r;)

  ortree<N> t;

  (i:N:  s[i](.r=g[i].t, .a=t.in[i]); )
   
  t.out = c.a;    
}

export template<pint N;pbool has_else>
defproc arb_select(a1of1 c; r1of2 g[N-int(has_else)]; a1of1 s[N])
{
  { false : "Need to implement non-deterministic selection!" };
}

export 
defproc doloop(a1of1 c; r1of2 g; a1of1 s)
{
  bool _r;

  s.a = g.r;
  c.a = g.f;

  prs {
    c.r => _r-
    _r | g.t => s.r-
  }
}


/*
 * Build a completion tree using a combination of 2-input and 3-input
 * C-elements 
 */
export template<pint N>
defproc ctree (bool in[N]; bool out)
{
  bool tout;

  { N > 0 : "What?" };

  pint i, end, j;
  pbool isinv;
  isinv = false;
  i = 0;
  end = N-1;

  /* dynamic array that holds all the nodes in the completion tree */
  bool tmp[N];
  (k:N:tmp[k] = in[k];)

  /* Invariant: i <= end */
    
  *[ i != end ->
     /* 
      * Invariant: tmp[i..end] has the current signals that need to be
      * combined together, and "isinv" specifies if they are the inverted
      * sense or not
      */
     j = 0;
     *[ i < end ->
	/*-- there are still signals that need to be combined --*/
	j = j + 1;
	bool tmp[end+j..end+j];
	[ i+2 >= end ->
	  /*-- last piece: use either a 2 or 3 input C-element --*/
	  prs { (&k:i..end:tmp[k]) #> tmp[end+j]- }
	  i = end;
        [] else ->
	  /*-- more to come; so use a two input C-element --*/
          prs { (&k:i..i+1:tmp[k]) #> tmp[end+j]- }
	  i = i + 2;
	]
      ]
      /*-- we just added an inverting layer --*/
      isinv = ~isinv;

      /*-- update range that has to be combined --*/
      i = end+1;
      end = end+j;
      j = 0;
  ]
  /*-- invert the signal if needed --*/
  [isinv -> prs { tmp[end] => out- } 
  [] else -> tmp[end] = out;
  ]
}
    
/*-- composition --*/
export template<pint N>
defproc comma(a1of1 c; a1of1 stmts[N])
{
  (i:N: c.r = stmts[i].r;)
  /* completion tree */
  ctree<N> ct(,c.a);
  (i:N: ct.in[i] = stmts[i].a;)
}


/*-- full sequencer --*/
export defproc fullseq (a1of1 go; a1of1 r)
{
  bool x, _gor, _goa, _ra;
  prs {
      ~x & ~_gor -> r.r+
      ~_ra -> x+
      Reset | x -> r.r-
      x & _ra -> _goa-
      _gor -> x-
      ~x -> _goa+
      go.r => _gor-
      _goa => go.a-
      r.a => _ra-
 }
}
  
export template<pint N>
defproc semi(a1of1 c; a1of1 stmts[N])
{
  fullseq f[N];
  (i:N: f[i].r = stmts[i];)
  (i:N-1: f[i].go.a = f[i+1].go.r;)
  c.r = f[0].go.r;
  c.a = f[N-1].go.a;
}

export namespace expr {

function max(pint a, b) : pint
{
 chp {
   self := (a > b) ? a : b
 }     
}

export template<pint W1,W2>
defproc and(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

export template<pint W1,W2>
defproc or(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

export template<pint W1,W2>
defproc xor(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

  
export template<pint W1,W2>
defproc add(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out);

export template<pint W1,W2>
defproc sub(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out);

export template<pint W1,W2>
defproc mult(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+W2+1> out);

export template<pint W1,W2>
defproc div(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);
  
export template<pint W1,W2>
defproc mod(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W2> out);
  
export template<pint W1,W2>
defproc lsl(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+(1<<W2)> out);

export template<pint W1,W2>
defproc lsr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);
  
export template<pint W1,W2>
defproc asr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);

export template<pint W1,W2>
defproc lt(sdtexprchan<W1> a; sdtexprchan<W2> b; r1of2 out);

export template<pint W1,W2>
defproc gt(sdtexprchan<W1> a; sdtexprchan<W2> b; r1of2 out);
  
export template<pint W1,W2>
defproc le(sdtexprchan<W1> a; sdtexprchan<W2> b; r1of2 out);

export template<pint W1,W2>
defproc ge(sdtexprchan<W1> a; sdtexprchan<W2> b; r1of2 out);
  
export template<pint W1,W2>
defproc lt(sdtexprchan<W1> a; sdtexprchan<W2> b; r1of2 out);

export template<pint W1,W2>
defproc eq(sdtexprchan<W1> a; sdtexprchan<W2> b; r1of2 out);

export template<pint W1,W2>
defproc ne(sdtexprchan<W1> a; sdtexprchan<W2> b; r1of2 out);

export template<pint W>
defproc uminus(sdtexprchan<W> a; sdtexprchan<W> out);
  
export template<pint W>
defproc not(sdtexprchan<W> a; sdtexprchan<W> out);
  
export template<pint W1,W2>
defproc ite(r1of2 a; sdtexprchan<W1> opt1; sdtexprchan<W2> opt2; sdtexprchan<max(W1,W2)> out);

export template<pint W1, W2>
defproc widthconv(sdtexprchan<W1> a; sdtexprchan<W2> out);

export template<pint W,V>
defproc const(sdtexprchan<W> out);

/*-- we need to fix this for variables ---*/
export template<pint W>
defproc writevar(sdtexprchan<W> a; sdtvar<W> var);

export template<pint W>
defproc readvar(sdtvar<W> var; sdtexprchan<W> out);

}


}
