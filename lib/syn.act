/*************************************************************************
 *
 *  Copyright (c) 2020 Rajit Manohar
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 *
 **************************************************************************
 */
import "globals.act";

/* Syntax directed translation */
  
namespace syn {

/*-- variable state --*/
export template<pint W; pbool I>
defproc var_init(sdtvar<W> v);
  
/*-- basic statements --*/
export
defproc sskip(a1of1 c)
{
  c.r = c.a;
}

/*
 * Build an OR-gate tree (NOR/NAND/optional INV)
 */
export template<pint N>
defproc ortree (bool? in[N]; bool out)
{
  bool tout;

  { N > 0 : "What?" };

  pint i, end, j;
  pbool isinv;
  isinv = false;
  i = 0;
  end = N-1;

  /* dynamic array that holds all the nodes in the completion tree */
  bool tmp[N];
  (k:N:tmp[k] = in[k];)

  /* Invariant: i <= end */
    
  *[ i != end ->
     /* 
      * Invariant: tmp[i..end] has the current signals that need to be
      * combined together, and "isinv" specifies if they are the inverted
      * sense or not
      */
     j = 0;
     *[ i < end ->
	/*-- there are still signals that need to be combined --*/
	j = j + 1;
	bool tmp[end+j..end+j];
	[ i+2 >= end ->
	  /*-- last piece: use either a 2 or 3 input C-element --*/
	  [isinv -> 
	     prs { (&k:i..end:tmp[k]) => tmp[end+j]- }
	  [] else ->
	     prs { (|k:i..end:tmp[k]) => tmp[end+j]- }
          ]	      
	  i = end;
        [] else ->
	  /*-- more to come; so use a two input C-element --*/
	  [isinv -> 
	     prs { (&k:i..i+1:tmp[k]) => tmp[end+j]- }
	  [] else ->
	     prs { (|k:i..i+1:tmp[k]) => tmp[end+j]- }
          ]	      
	  i = i + 2;
	]
      ]
      /*-- we just added an inverting layer --*/
      isinv = ~isinv;

      /*-- update range that has to be combined --*/
      i = end+1;
      end = end+j;
      j = 0;
  ]
  /*-- invert the signal if needed --*/
  [isinv -> prs { tmp[end] => out- } 
  [] else -> tmp[end] = out;
  ]
}
  
/*-- compound statements --*/
export template<pint N>
defproc loop(a1of1? c; sdtexprchan?<1> gg[N]; a1of1! s[N])
{
  r1of2 g[N];
  (i:N: sdt_connect_r1of2 conn[i..i]; conn[i](g[i],gg[i]); )
  /* loop: evaluate guards serially */
  (i:N-1: g[i].f = g[i+1].r;)
  g[N-1].f = c.a;
    
  ortree<N> ot;
  (i:N: s[i](.r=g[i].t, .a=ot.in[i]); )

  bool _r;

  prs {
    c.r => _r-
    _r | ot.out => g[0].r-
  }
}

export template<pint N;pbool has_else>
defproc select(a1of1? c; sdtexprchan?<1> gg[N]; a1of1! s[N+int(has_else)])
{
  r1of2 g[N];
  (i:N: sdt_connect_r1of2 conn[i..i]; conn[i](g[i],gg[i]);)
  (i:N-1: g[i].f = g[i+1].r;)

  ortree<N+int(has_else)> ot;
  
  [ has_else -> (i:N:  s[i](.r=g[i].t, .a=ot.in[i]); )
                s[N].r = g[N-1].f;
                s[N].a = ot.in[N-1];
  [] ~has_else -> (i:N: s[i](.r=g[i].t, .a=ot.in[i]); )
  ]
   
  ot.out = c.a;    
}

export template<pint N;pbool has_else>
defproc arb_select(a1of1? c; sdtexprchan?<1> g[N]; a1of1! s[N+int(has_else)])
{
  { false : "Need to implement non-deterministic selection!" };
}

export 
defproc doloop(a1of1? c; sdtexprchan?<1> gg; a1of1! s)
{
  bool _r;
  r1of2 g;

  sdt_connect_r1of2 conn(g,gg);

  s.a = g.r;
  c.a = g.f;

  prs {
    c.r => _r-
    _r | g.t => s.r-
  }
}


/*
 * Build a completion tree using a combination of 2-input and 3-input
 * C-elements 
 */
export template<pint N>
defproc ctree (bool? in[N]; bool out)
{
  bool tout;

  { N > 0 : "What?" };

  pint i, end, j;
  pbool isinv;
  isinv = false;
  i = 0;
  end = N-1;

  /* dynamic array that holds all the nodes in the completion tree */
  bool tmp[N];
  (k:N:tmp[k] = in[k];)

  /* Invariant: i <= end */
    
  *[ i != end ->
     /* 
      * Invariant: tmp[i..end] has the current signals that need to be
      * combined together, and "isinv" specifies if they are the inverted
      * sense or not
      */
     j = 0;
     *[ i < end ->
	/*-- there are still signals that need to be combined --*/
	j = j + 1;
	bool tmp[end+j..end+j];
	[ i+2 >= end ->
	  /*-- last piece: use either a 2 or 3 input C-element --*/
	  prs { (&k:i..end:tmp[k]) #> tmp[end+j]- }
	  i = end;
        [] else ->
	  /*-- more to come; so use a two input C-element --*/
          prs { (&k:i..i+1:tmp[k]) #> tmp[end+j]- }
	  i = i + 2;
	]
      ]
      /*-- we just added an inverting layer --*/
      isinv = ~isinv;

      /*-- update range that has to be combined --*/
      i = end+1;
      end = end+j;
      j = 0;
  ]
  /*-- invert the signal if needed --*/
  [isinv -> prs { tmp[end] => out- } 
  [] else -> tmp[end] = out;
  ]
}

export template<pint N>
defproc sigbuf (bool in, out)
{
 { N > 0 : "sigbuf: parameter error" };

 bool _out;

 [ N < 8 -> in = out;
 [] else ->
      sigbuf<N/8> sb(in);
      prs {
      	 sb.out => _out-
	 _out   => out-
      }
      sizing {
      	 _out {-N/4}; out {-N}
      }
 ]
}

/*-- composition --*/
export template<pint N>
defproc comma(a1of1? c; a1of1 stmts[N])
{
  /* fanout driver */
  sigbuf<N> s(c.r);
  
  (i:N: s.out = stmts[i].r;)
    
  /* completion tree */
  ctree<N> ct(,c.a);
  (i:N: ct.in[i] = stmts[i].a;)
}


/*-- full sequencer --*/
export defproc fullseq (a1of1? go; a1of1! r)
{
  bool x, _gor, _goa, _ra;
  prs {
      ~x & ~_gor -> r.r+
      ~_ra -> x+
      Reset | x -> r.r-
      x & _ra -> _goa-
      _gor -> x-
      ~x -> _goa+
      go.r => _gor-
      _goa => go.a-
      r.a => _ra-
 }
}
  
export template<pint N>
defproc semi(a1of1? c; a1of1! stmts[N])
{
  fullseq f[N];
  (i:N: f[i].r = stmts[i];)
  (i:N-1: f[i].go.a = f[i+1].go.r;)
  c.r = f[0].go.r;
  c.a = f[N-1].go.a;
}


export template<pint W>
defproc transfer(a1of1? c; sdtexprchan?<W> e; sdtchan!<W> ch);

export template<pint W>
defproc recv(a1of1 c; sdtchan<W> ch; sdtvar<W> var);

export template<pint W,N>
defproc muxinport(sdtchan?<W> c; sdtchan<W> m[N]);

export template<pint W,N>
defproc muxoutport(sdtchan!<W> c; sdtchan<W> m[N]);

export namespace expr {

function max(pint a, b) : pint
{
 chp {
   self := (a > b) ? a : b
 }     
}

export template<pint W1,W2>
defproc and(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

export template<pint W1,W2>
defproc or(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

export template<pint W1,W2>
defproc xor(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)> out);

  
export template<pint W1,W2>
defproc add(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out);

export template<pint W1,W2>
defproc sub(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<max(W1,W2)+1> out);

export template<pint W1,W2>
defproc mult(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+W2> out);

export template<pint W1,W2>
defproc div(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);
  
export template<pint W1,W2>
defproc mod(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W2> out);
  
export template<pint W1,W2>
defproc lsl(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1+(1<<W2)> out);

export template<pint W1,W2>
defproc lsr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);
  
export template<pint W1,W2>
defproc asr(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<W1> out);

export template<pint W1,W2>
defproc lt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc gt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);
  
export template<pint W1,W2>
defproc le(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc ge(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);
  
export template<pint W1,W2>
defproc lt(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc eq(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W1,W2>
defproc ne(sdtexprchan<W1> a; sdtexprchan<W2> b; sdtexprchan<1> out);

export template<pint W>
defproc uminus(sdtexprchan<W> a; sdtexprchan<W> out);
  
export template<pint W>
defproc not(sdtexprchan<W> a; sdtexprchan<W> out);
  
export template<pint W1,W2>
defproc ite(sdtexprchan<1> a; sdtexprchan<W1> opt1; sdtexprchan<W2> opt2; sdtexprchan<max(W1,W2)> out);

export template<pint W1, W2>
defproc widthconv(sdtexprchan<W1> a; sdtexprchan<W2> out);

export template<pint W,V>
defproc const(sdtexprchan<W> out);

/*-- we need to fix this for variables ---*/
export template<pint W>
defproc writeport(sdtvar<W> var; sdtchan<W> in);

export template<pint W>
defproc readport(sdtvar<W> var; sdtexprchan<W> out);

}

}
